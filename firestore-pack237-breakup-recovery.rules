rules_version = '2';

/**
 * PACK 237: Breakup Recovery & Restart Path - Firestore Security Rules
 * 
 * Protects breakup recovery data, ended connections, recovery feed, and safety incidents.
 * Ensures users can only access their own recovery data with proper authentication.
 */

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ========================================================================
    // HELPER FUNCTIONS
    // ========================================================================
    
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isUser(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }
    
    function isModerator() {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['admin', 'moderator'];
    }
    
    // ========================================================================
    // BREAKUP RECOVERY STATES
    // ========================================================================
    
    match /breakup_recovery_states/{recoveryId} {
      // Read: Only the user themselves or admins
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      
      // Create: Only by Cloud Functions (no direct user creation)
      allow create: if false;
      
      // Update: Only the user themselves (for limited fields) or Cloud Functions
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        // Users can only update these fields:
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['emotionalSignals', 'closingNote', 'updatedAt']) &&
        // Ensure userId cannot be changed
        request.resource.data.userId == resource.data.userId;
      
      // Delete: Never allow direct deletion
      allow delete: if false;
    }
    
    // ========================================================================
    // END CONNECTION REQUESTS
    // ========================================================================
    
    match /end_connection_requests/{requestId} {
      // Read: Only the initiator or respondent
      allow read: if isAuthenticated() && (
        resource.data.initiatorId == request.auth.uid ||
        resource.data.respondentId == request.auth.uid ||
        isAdmin()
      );
      
      // Create: Only the initiator can create
      allow create: if isAuthenticated() &&
        request.resource.data.initiatorId == request.auth.uid &&
        request.resource.data.status == 'pending_confirmation' &&
        // Ensure proper structure
        request.resource.data.keys().hasAll([
          'requestId', 'connectionId', 'initiatorId', 'respondentId',
          'closingNote', 'status', 'expiresAt', 'createdAt', 'updatedAt'
        ]);
      
      // Update: Only respondent can confirm/decline
      allow update: if isAuthenticated() &&
        resource.data.respondentId == request.auth.uid &&
        resource.data.status == 'pending_confirmation' &&
        request.resource.data.status in ['confirmed', 'declined'] &&
        // Only allow changing status and timestamps
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['status', 'confirmedAt', 'declinedAt', 'updatedAt']);
      
      // Delete: Never allow
      allow delete: if false;
    }
    
    // ========================================================================
    // ENDED CONNECTIONS
    // ========================================================================
    
    match /ended_connections/{connectionId} {
      // Read: Only users involved in the connection
      allow read: if isAuthenticated() && (
        resource.data.user1Id == request.auth.uid ||
        resource.data.user2Id == request.auth.uid ||
        isAdmin()
      );
      
      // Create: Only by Cloud Functions
      allow create: if false;
      
      // Update: Users can update their own closing note and visibility choice
      allow update: if isAuthenticated() && (
        (resource.data.user1Id == request.auth.uid &&
         request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['user1ClosingNote', 'profileVisibilityChoice'])) ||
        (resource.data.user2Id == request.auth.uid &&
         request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['user2ClosingNote', 'profileVisibilityChoice']))
      );
      
      // Delete: Never allow
      allow delete: if false;
    }
    
    // ========================================================================
    // RECOVERY FEED ITEMS
    // ========================================================================
    
    match /recovery_feed_items/{itemId} {
      // Read: Only the user themselves
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      
      // Create: Only by Cloud Functions
      allow create: if false;
      
      // Update: Users can mark items as viewed/interacted/dismissed
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid &&
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['viewedAt', 'interactedAt', 'dismissedAt', 'actionTaken']);
      
      // Delete: Never allow
      allow delete: if false;
    }
    
    // ========================================================================
    // RESTART PATH OFFERS
    // ========================================================================
    
    match /restart_path_offers/{offerId} {
      // Read: Only the user themselves
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      
      // Create: Only by Cloud Functions
      allow create: if false;
      
      // Update: Users can mark as shown/purchased/declined
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid &&
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['shownAt', 'purchasedAt', 'declinedAt']);
      
      // Delete: Never allow
      allow delete: if false;
    }
    
    // ========================================================================
    // BREAKUP SAFETY INCIDENTS
    // ========================================================================
    
    match /breakup_safety_incidents/{incidentId} {
      // Read: Only the user involved or moderators
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isModerator()
      );
      
      // Create: Users can report incidents
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.keys().hasAll([
          'incidentId', 'userId', 'partnerId', 'connectionId',
          'type', 'severity', 'description', 'status', 'createdAt', 'updatedAt'
        ]);
      
      // Update: Only moderators can update
      allow update: if isModerator();
      
      // Delete: Only admins
      allow delete: if isAdmin();
    }
    
    // ========================================================================
    // BREAKUP RECOVERY ANALYTICS
    // ========================================================================
    
    match /breakup_recovery_analytics/{analyticsId} {
      // Read: Only the user themselves or admins
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      
      // Create: Only by Cloud Functions
      allow create: if false;
      
      // Update: Only by Cloud Functions
      allow update: if false;
      
      // Delete: Only admins
      allow delete: if isAdmin();
    }
  }
}